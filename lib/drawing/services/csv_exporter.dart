import 'package:latlong2/latlong.dart';
import 'package:geolocator/geolocator.dart';
import 'dart:math' as math;

/// CSV exporter for comprehensive tree and drawing data reports.
/// Generates CSV files compatible with Excel, GIS software, and databases.
class CsvExporter {
  /// Export tree data with coordinates to CSV format
  static String exportTreeDataToCsv({
    required List<Map<String, dynamic>> elements,
    required String siteName,
    String? siteAddress,
    String? surveyorName,
    DateTime? surveyDate,
  }) {
    final buffer = StringBuffer();
    
    // Add header information
    buffer.writeln('# Arborist Tree Survey Report');
    buffer.writeln('# Site: $siteName');
    if (siteAddress != null) buffer.writeln('# Address: $siteAddress');
    if (surveyorName != null) buffer.writeln('# Surveyor: $surveyorName');
    buffer.writeln('# Date: ${(surveyDate ?? DateTime.now()).toString().split(' ')[0]}');
    buffer.writeln('# Generated by Arborist Assistant');
    buffer.writeln('#');
    
    // CSV headers for tree data
    buffer.writeln([
      'Tree_ID',
      'Species',
      'Common_Name',
      'Latitude',
      'Longitude',
      'DBH_cm',
      'Height_m',
      'Canopy_Spread_m',
      'Condition',
      'Health_Rating',
      'Structure_Rating',
      'TPZ_Radius_m',
      'SRZ_Radius_m',
      'Retention_Value',
      'Risk_Rating',
      'Recommended_Actions',
      'Notes',
      'Survey_Date',
      'Last_Modified'
    ].join(','));
    
    // Filter and export tree elements
    final treeElements = elements.where((e) => e['type'] == 'tree').toList();
    
    for (final tree in treeElements) {
      final point = tree['point'] as LatLng;
      final treeId = tree['treeId'] ?? '';
      final species = tree['species'] ?? '';
      final commonName = tree['commonName'] ?? '';
      final dbh = (tree['dbh'] as double?) ?? 0.0;
      final height = (tree['height'] as double?) ?? 0.0;
      final canopySpread = (tree['canopySpread'] as double?) ?? 0.0;
      final condition = tree['condition'] ?? '';
      final healthRating = tree['healthRating'] ?? '';
      final structureRating = tree['structureRating'] ?? '';
      final retentionValue = tree['retentionValue'] ?? '';
      final riskRating = tree['riskRating'] ?? '';
      final recommendedActions = tree['recommendedActions'] ?? '';
      final notes = (tree['notes'] as String? ?? '').replaceAll(',', ';'); // Escape commas
      
      // Calculate TPZ and SRZ using AS 4970 formulas
      final tpzRadius = _calculateTPZRadius(dbh);
      final srzRadius = _calculateSRZRadius(dbh);
      
      buffer.writeln([
        _escapeCsvField(treeId),
        _escapeCsvField(species),
        _escapeCsvField(commonName),
        point.latitude.toStringAsFixed(8),
        point.longitude.toStringAsFixed(8),
        dbh.toStringAsFixed(1),
        height.toStringAsFixed(1),
        canopySpread.toStringAsFixed(1),
        _escapeCsvField(condition),
        _escapeCsvField(healthRating),
        _escapeCsvField(structureRating),
        tpzRadius.toStringAsFixed(2),
        srzRadius.toStringAsFixed(2),
        _escapeCsvField(retentionValue),
        _escapeCsvField(riskRating),
        _escapeCsvField(recommendedActions),
        _escapeCsvField(notes),
        (surveyDate ?? DateTime.now()).toString().split(' ')[0],
        DateTime.now().toIso8601String(),
      ].join(','));
    }
    
    return buffer.toString();
  }
  
  /// Export drawing elements with coordinates to CSV format
  static String exportDrawingElementsToCsv({
    required List<Map<String, dynamic>> elements,
    required String siteName,
  }) {
    final buffer = StringBuffer();
    
    // Add header information
    buffer.writeln('# Arborist Drawing Elements Report');
    buffer.writeln('# Site: $siteName');
    buffer.writeln('# Generated: ${DateTime.now().toString().split(' ')[0]}');
    buffer.writeln('#');
    
    // CSV headers for drawing elements
    buffer.writeln([
      'Element_ID',
      'Type',
      'Layer_ID',
      'Label',
      'Start_Latitude',
      'Start_Longitude',
      'End_Latitude',
      'End_Longitude',
      'Center_Latitude',
      'Center_Longitude',
      'Length_m',
      'Area_sqm',
      'Perimeter_m',
      'Color',
      'Line_Width',
      'Fill_Opacity',
      'Created_Date',
      'Notes'
    ].join(','));
    
    // Export each drawing element
    for (int i = 0; i < elements.length; i++) {
      final element = elements[i];
      final type = element['type'] as String;
      final layerId = element['layerId'] ?? '';
      final label = element['label'] ?? element['text'] ?? '';
      final color = element['color']?.toString() ?? '';
      final lineWidth = (element['width'] as double?)?.toStringAsFixed(1) ?? '';
      final fillOpacity = (element['fillAlpha'] as double?)?.toStringAsFixed(2) ?? '';
      final notes = (element['notes'] as String? ?? '').replaceAll(',', ';');
      
      double? startLat, startLon, endLat, endLon, centerLat, centerLon;
      double? length, area, perimeter;
      
      if (element['point'] is LatLng) {
        // Point elements (trees, text)
        final point = element['point'] as LatLng;
        startLat = centerLat = point.latitude;
        startLon = centerLon = point.longitude;
      } else if (element['points'] is List<LatLng>) {
        final points = element['points'] as List<LatLng>;
        if (points.isNotEmpty) {
          startLat = points.first.latitude;
          startLon = points.first.longitude;
          if (points.length > 1) {
            endLat = points.last.latitude;
            endLon = points.last.longitude;
          }
          
          // Calculate center point
          centerLat = points.map((p) => p.latitude).reduce((a, b) => a + b) / points.length;
          centerLon = points.map((p) => p.longitude).reduce((a, b) => a + b) / points.length;
          
          // Calculate measurements
          if (type == 'line' && points.length == 2) {
            length = const Distance().as(LengthUnit.Meter, points[0], points[1]);
          } else if (type == 'polyline' || type == 'polygon') {
            perimeter = _calculatePerimeter(points);
            if (type == 'polygon') {
              area = _calculatePolygonArea(points);
            }
          }
        }
      }
      
      buffer.writeln([
        'ELEM_${i.toString().padLeft(4, '0')}',
        _escapeCsvField(type),
        _escapeCsvField(layerId),
        _escapeCsvField(label),
        startLat?.toStringAsFixed(8) ?? '',
        startLon?.toStringAsFixed(8) ?? '',
        endLat?.toStringAsFixed(8) ?? '',
        endLon?.toStringAsFixed(8) ?? '',
        centerLat?.toStringAsFixed(8) ?? '',
        centerLon?.toStringAsFixed(8) ?? '',
        length?.toStringAsFixed(2) ?? '',
        area?.toStringAsFixed(2) ?? '',
        perimeter?.toStringAsFixed(2) ?? '',
        _escapeCsvField(color),
        lineWidth,
        fillOpacity,
        DateTime.now().toString().split(' ')[0],
        _escapeCsvField(notes),
      ].join(','));
    }
    
    return buffer.toString();
  }
  
  /// Export comprehensive site report with all data
  static String exportSiteReportToCsv({
    required List<Map<String, dynamic>> elements,
    required String siteName,
    String? siteAddress,
    String? surveyorName,
    DateTime? surveyDate,
    Map<String, dynamic>? siteData,
  }) {
    final buffer = StringBuffer();
    
    // Site summary section
    buffer.writeln('# ARBORIST SITE REPORT');
    buffer.writeln('# ==================');
    buffer.writeln('#');
    buffer.writeln('# Site Information');
    buffer.writeln('Site_Name,$siteName');
    if (siteAddress != null) buffer.writeln('Site_Address,"$siteAddress"');
    if (surveyorName != null) buffer.writeln('Surveyor,"$surveyorName"');
    buffer.writeln('Survey_Date,${(surveyDate ?? DateTime.now()).toString().split(' ')[0]}');
    buffer.writeln('Report_Generated,${DateTime.now().toIso8601String()}');
    
    // Site statistics
    final treeCount = elements.where((e) => e['type'] == 'tree').length;
    final tpzCount = elements.where((e) => e['layerId'] == 'tpz').length;
    final srzCount = elements.where((e) => e['layerId'] == 'srz').length;
    final measurementCount = elements.where((e) => e['type'] == 'dimension').length;
    
    buffer.writeln('#');
    buffer.writeln('# Site Statistics');
    buffer.writeln('Total_Trees,$treeCount');
    buffer.writeln('TPZ_Zones,$tpzCount');
    buffer.writeln('SRZ_Zones,$srzCount');
    buffer.writeln('Measurements,$measurementCount');
    buffer.writeln('Total_Elements,${elements.length}');
    
    // Calculate total protection area
    double totalTPZArea = 0.0;
    double totalSRZArea = 0.0;
    
    for (final element in elements) {
      if (element['layerId'] == 'tpz' && element['points'] is List<LatLng>) {
        totalTPZArea += _calculatePolygonArea(element['points'] as List<LatLng>);
      } else if (element['layerId'] == 'srz' && element['points'] is List<LatLng>) {
        totalSRZArea += _calculatePolygonArea(element['points'] as List<LatLng>);
      }
    }
    
    buffer.writeln('Total_TPZ_Area_sqm,${totalTPZArea.toStringAsFixed(2)}');
    buffer.writeln('Total_SRZ_Area_sqm,${totalSRZArea.toStringAsFixed(2)}');
    
    buffer.writeln('#');
    buffer.writeln('# ==================');
    buffer.writeln('#');
    
    // Append tree data
    buffer.writeln('# TREE INVENTORY');
    buffer.writeln('#');
    buffer.write(exportTreeDataToCsv(
      elements: elements,
      siteName: siteName,
      siteAddress: siteAddress,
      surveyorName: surveyorName,
      surveyDate: surveyDate,
    ).split('\n').where((line) => !line.startsWith('#')).join('\n'));
    
    buffer.writeln('#');
    buffer.writeln('# DRAWING ELEMENTS');
    buffer.writeln('#');
    buffer.write(exportDrawingElementsToCsv(
      elements: elements,
      siteName: siteName,
    ).split('\n').where((line) => !line.startsWith('#')).join('\n'));
    
    return buffer.toString();
  }
  
  // Helper methods
  
  /// Escape CSV field and handle special characters
  static String _escapeCsvField(String field) {
    if (field.isEmpty) return '';
    
    // Escape quotes and wrap in quotes if contains comma, quote, or newline
    if (field.contains(',') || field.contains('"') || field.contains('\n')) {
      return '"${field.replaceAll('"', '""')}"';
    }
    return field;
  }
  
  /// Calculate TPZ radius using AS 4970 formula
  static double _calculateTPZRadius(double dbhCm) {
    final radius = dbhCm * 0.12; // DBH × 12 × 0.01
    return radius.clamp(2.0, 15.0); // Min 2m, Max 15m
  }
  
  /// Calculate SRZ radius using AS 4970 formula
  static double _calculateSRZRadius(double dbhCm) {
    final dMeters = dbhCm / 100.0;
    if (dMeters <= 0) return 0.0;
    final base = dMeters * 50.0;
    final radius = math.pow(base, 0.42) * 0.64;
    return radius.toDouble();
  }
  
  /// Calculate perimeter of a polygon
  static double _calculatePerimeter(List<LatLng> points) {
    if (points.length < 2) return 0.0;
    
    double perimeter = 0.0;
    for (int i = 0; i < points.length; i++) {
      final next = (i + 1) % points.length;
      perimeter += const Distance().as(LengthUnit.Meter, points[i], points[next]);
    }
    return perimeter;
  }
  
  /// Calculate area of a polygon using Shoelace formula (approximate for small areas)
  static double _calculatePolygonArea(List<LatLng> points) {
    if (points.length < 3) return 0.0;
    
    double area = 0.0;
    for (int i = 0; i < points.length; i++) {
      final j = (i + 1) % points.length;
      area += points[i].longitude * points[j].latitude;
      area -= points[j].longitude * points[i].latitude;
    }
    area = area.abs() / 2.0;
    
    // Convert from degrees² to m² (approximate for small areas)
    // This is a rough approximation - for precise calculations use proper projection
    const double degToM = 111320.0; // meters per degree at equator
    return area * degToM * degToM;
  }
}
