import 'dart:convert';
import 'dart:io';
import 'dart:ui' as ui;
import 'dart:math';

import 'package:arborist_assistant/models/site.dart';
import 'package:arborist_assistant/services/drawing_storage_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:uuid/uuid.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter_colorpicker/flutter_colorpicker.dart';
import 'package:geolocator/geolocator.dart';

import '../models/tree_entry.dart';
import '../services/pdf_export_service.dart';
import '../services/tree_storage_service.dart';


// === ArborCAD Models ===
class DrawingLayer {
  final String id;
  String name;
  Color color;
  double opacity;
  bool visible;
  bool locked;

  DrawingLayer({
    required this.id,
    this.name = 'New Layer',
    this.color = Colors.black,
    this.opacity = 1.0,
    this.visible = true,
    this.locked = false,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'color': color.value,
        'opacity': opacity,
        'visible': visible,
        'locked': locked,
      };

  factory DrawingLayer.fromJson(Map<String, dynamic> json) => DrawingLayer(
        id: json['id'],
        name: json['name'],
        color: Color(json['color']),
        opacity: json['opacity'],
        visible: json['visible'],
        locked: json['locked'] ?? false,
      );
}

class DrawingElement {
  final String id;
  final String type; // 'line', 'polygon', 'circle', 'text', 'tree', 'dimension', etc.
  String layerId;
  LatLng? latLng;
  LatLng? endLatLng;
  List<LatLng>? latLngPoints;
  double? radius; // For circles, in screen pixels
  String? text;
  Color color;
  double? lineWidth;
  String? fillStyle; // 'none', 'solid', 'hatch'
  Map<String, dynamic>? metadata;

  DrawingElement({
    required this.id,
    required this.type,
    required this.layerId,
    this.latLng,
    this.endLatLng,
    this.latLngPoints,
    this.radius,
    this.text,
    this.color = Colors.black,
    this.lineWidth,
    this.fillStyle,
    this.metadata,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'type': type,
        'layerId': layerId,
        'latLng': latLng != null ? {'lat': latLng!.latitude, 'lng': latLng!.longitude} : null,
        'endLatLng': endLatLng != null ? {'lat': endLatLng!.latitude, 'lng': endLatLng!.longitude} : null,
        'latLngPoints': latLngPoints?.map((p) => {'lat': p.latitude, 'lng': p.longitude}).toList(),
        'radius': radius,
        'text': text,
        'color': color.value,
        'lineWidth': lineWidth,
        'fillStyle': fillStyle,
        'metadata': metadata,
      };

  factory DrawingElement.fromJson(Map<String, dynamic> json) {
    return DrawingElement(
      id: json['id'],
      type: json['type'],
      layerId: json['layerId'],
      latLng: json['latLng'] != null ? LatLng(json['latLng']['lat'], json['latLng']['lng']) : null,
      endLatLng: json['endLatLng'] != null ? LatLng(json['endLatLng']['lat'], json['endLatLng']['lng']) : null,
      latLngPoints: (json['latLngPoints'] as List<dynamic>?)
          ?.map((p) => LatLng(p['lat'], p['lng']))
          .toList(),
      radius: json['radius'],
      text: json['text'],
      color: Color(json['color']),
      lineWidth: json['lineWidth'],
      fillStyle: json['fillStyle'],
      metadata: json['metadata'] != null
          ? Map<String, dynamic>.from(json['metadata'])
          : null,
    );
  }
}

class TreeProtectionZone {
  final LatLng center;
  final double tpzRadius; // in meters
  final double srzRadius; // in meters

  TreeProtectionZone({
    required this.center,
    required this.tpzRadius,
    required this.srzRadius,
  });
}

class ImageOverlay {
  final String id;
  final String imagePath;
  LatLng center;
  double width; // in meters
  double height; // in meters
  double rotation; // in degrees
  double opacity;

  ImageOverlay({
    required this.id,
    required this.imagePath,
    required this.center,
    required this.width,
    required this.height,
    this.rotation = 0.0,
    this.opacity = 0.8,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'imagePath': imagePath,
        'center': center.toJson(),
        'width': width,
        'height': height,
        'rotation': rotation,
        'opacity': opacity,
      };

  factory ImageOverlay.fromJson(Map<String, dynamic> json) => ImageOverlay(
        id: json['id'],
        imagePath: json['imagePath'],
        center: LatLng(json['center']['lat'], json['center']['lng']),
        width: json['width'],
        height: json['height'],
        rotation: json['rotation'] ?? 0.0,
        opacity: json['opacity'] ?? 0.8,
      );
}

// === Drawing Page Widget ===
class SimpleDrawingPage extends StatefulWidget {
  final Site site;
  
  const SimpleDrawingPage({Key? key, required this.site}) : super(key: key);

  @override
  State<SimpleDrawingPage> createState() => _SimpleDrawingPageState();
}

class _SimpleDrawingPageState extends State<SimpleDrawingPage> {
  final MapController _mapController = MapController();
  List<List<DrawingElement>> _undoStack = [];
  List<List<DrawingElement>> _redoStack = [];
  List<DrawingElement> _elements = [];
  List<DrawingLayer> _layers = [
    DrawingLayer(id: 'default', name: 'Default', color: Colors.black)
  ];
  String _selectedLayerId = 'default';
  String? _selectedElementId;
  ImageOverlay? _imageOverlay;
  final ImagePicker _picker = ImagePicker();

  // Map Tile Layer state
  int _currentTileLayerIndex = 0;
  final List<Map<String, String>> _tileLayers = [
    {
      'name': 'Satellite',
      'url': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    },
    {
      'name': 'Street',
      'url': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    },
    {
      'name': 'Topographic',
      'url': 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    },
  ];
  double _tileLayerOpacity = 1.0;

  String _currentTool = 'select'; // 'select', 'line', 'polygon', 'circle', etc.
  List<Offset> _currentPolyline = [];
  Offset? _previewPoint;
  
  // Drawing properties
  double _strokeWidth = 2.0;
  Color _drawingColor = Colors.red;
  String _fillStyle = 'none'; // 'none', 'solid', 'hatch', 'dots'
  bool _autoDrawMode = false;
  String _autoDrawType = 'house'; // 'house', 'driveway', 'boundary', 'garden'

  List<TreeProtectionZone> _treeZones = [];
  bool _showTreeZones = false;
  bool _drawMode = true;

  bool _treesLoaded = false;

  // Editing state
  bool _isMovingSelection = false;
  int? _resizeHandleIndex;
  String? _selectedOverlayAction; // 'move', 'rotate', 'scale_br'

  // Snapping State
  bool _isSnappingEnabled = true;
  SnapPoint? _snapPoint;

  DrawingElement? _selectedElement;

  @override
  void initState() {
    super.initState();
    _loadDrawing();
    _loadTreesAndGenerateElements();
  }

  Future<void> _loadTreesAndGenerateElements() async {
    final trees = await TreeStorageService.getTreesForSite(widget.site.id);
    final treeElements = trees.map((tree) {
      return DrawingElement(
        id: 'tree-${tree.id}',
        type: 'tree',
        layerId: 'default', // Or a dedicated tree layer
        latLng: LatLng(tree.latitude, tree.longitude),
        metadata: {
          'treeNumber': tree.id,
          'retentionValue': tree.retentionValue,
          'tpzRadius': tree.nrz,
          'srzRadius': tree.srz,
        },
      );
    }).toList();
    setState(() {
      _elements.removeWhere((e) => e.type == 'tree');
      _elements.addAll(treeElements);
      _treesLoaded = true;
    });
  }

  Future<void> _loadDrawing() async {
    final data = await DrawingStorageService.loadDrawing(widget.site.id);
    if (data != null) {
      setState(() {
        _elements = (data['actions'] as List)
            .map((e) => DrawingElement.fromJson(e))
            .toList();
        _imageOverlay = data['overlay'] != null
            ? ImageOverlay.fromJson(data['overlay'])
            : null;
        if (data['layers'] != null) {
          _layers = (data['layers'] as List)
              .map((l) => DrawingLayer.fromJson(l))
              .toList();
        }
      });
    }
  }

  Future<void> _saveDrawing() async {
    await DrawingStorageService.saveDrawing(
        widget.site.id,
        _elements.map((e) => e.toJson()).toList(),
        _imageOverlay?.toJson(),
        _layers.map((l) => l.toJson()).toList());
    ScaffoldMessenger.of(context)
        .showSnackBar(SnackBar(content: Text('Drawing saved!')));
  }

  void _handleTap(Offset position) {
    if (_currentTool == 'select') {
      _selectElementAt(position);
      return;
    }

    if (_layers.firstWhere((l) => l.id == _selectedLayerId).locked) {
      ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Cannot draw on a locked layer.')));
      return;
    }

    // Add the new point and check if the drawing is finished outside of setState
    final updatedPolyline = [..._currentPolyline, position];
    bool isFinished = _isDrawingFinished(updatedPolyline.length);

    if (isFinished) {
      // If finished, we don't need to update the preview line, just finalize
      _finalizeDrawing(position, updatedPolyline);
    } else {
      // If not finished, update the preview line
      setState(() {
        _currentPolyline = updatedPolyline;
      });
    }
  }

  bool _isDrawingFinished(int pointCount) {
    switch (_currentTool) {
      case 'line':
      case 'circle':
      case 'dimension':
      case 'arrow':
      case 'rectangle':
        return pointCount >= 2;
      case 'text':
        return pointCount >= 1;
      default:
        return false;
    }
  }

  void _finalizeDrawing(Offset finalPoint, List<Offset> points) {
    if (points.isEmpty) return;

    final latLngPoints =
        points.map((p) => _mapController.camera.offsetToCrs(p)).toList();

    final id = Uuid().v4();
    DrawingElement? finalElement;

    switch (_currentTool) {
      case 'line':
      case 'dimension':
      case 'arrow':
        finalElement = DrawingElement(
            id: id,
            type: _currentTool,
            layerId: _selectedLayerId,
            latLng: latLngPoints.first,
            endLatLng: latLngPoints.last,
            lineWidth: _strokeWidth,
            color: _drawingColor);
        break;
      case 'circle':
        final center = latLngPoints.first;
        final radiusPoint = latLngPoints.last;
        final distanceInMeters = Geolocator.distanceBetween(center.latitude,
            center.longitude, radiusPoint.latitude, radiusPoint.longitude);
        final radiusInPixels = (finalPoint - points.first).distance;
        finalElement = DrawingElement(
            id: id,
            type: 'circle',
            layerId: _selectedLayerId,
            latLng: center,
            radius: radiusInPixels,
            metadata: {'radius_meters': distanceInMeters},
            lineWidth: _strokeWidth,
            fillStyle: _fillStyle,
            color: _drawingColor);
        break;
      case 'polygon':
      case 'encroachment':
      case 'paving':
      case 'planting':
        finalElement = DrawingElement(
            id: id,
            type: _currentTool,
            layerId: _selectedLayerId,
            latLngPoints: latLngPoints,
            fillStyle: _autoDrawMode ? _getAutoDrawFillStyle() : _fillStyle,
            lineWidth: _strokeWidth,
            color: _autoDrawMode ? _getAutoDrawColor() : _drawingColor);
        break;
      case 'rectangle':
        final p1 = latLngPoints.first;
        final p2 = latLngPoints.last;
        final rectPoints = [
          p1,
          LatLng(p1.latitude, p2.longitude),
          p2,
          LatLng(p2.latitude, p1.longitude)
        ];
        finalElement = DrawingElement(
            id: id,
            type: 'rectangle',
            layerId: _selectedLayerId,
            latLngPoints: rectPoints,
            lineWidth: _strokeWidth,
            fillStyle: _fillStyle,
            color: _drawingColor);
        break;
      case 'text':
        // Text is handled differently and calls its own setState
        _addTextElement(latLngPoints.first);
        return; // Return early to avoid resetting state here
    }

    if (finalElement != null) {
      setState(() {
        _elements.add(finalElement!);
        _resetDrawingState();
      });
    } else {
      _resetDrawingState();
    }
  }

  void _addTextElement(LatLng position) async {
    final textController = TextEditingController();
    final newText = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Enter Text'),
        content: TextField(
          controller: textController,
          autofocus: true,
        ),
        actions: [
          TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text('Cancel')),
          TextButton(
              onPressed: () =>
                  Navigator.of(context).pop(textController.text),
              child: Text('OK')),
        ],
      ),
    );

    if (newText != null && newText.isNotEmpty) {
      setState(() {
        _elements.add(DrawingElement(
          id: Uuid().v4(),
          type: 'text',
          layerId: _selectedLayerId,
          latLng: position,
          text: newText,
          color: _drawingColor,
        ));
      });
    }
    _resetDrawingState();
  }

  void _resetDrawingState() {
    setState(() {
      _currentPolyline = [];
      _previewPoint = null;
      // Don't reset tool to select - keep current tool active
    });
  }

  void _deleteSelectedElement() {
    if (_selectedElementId != null) {
      setState(() {
        _elements.removeWhere((e) => e.id == _selectedElementId);
        _selectedElementId = null;
      });
    }
  }

  void _toggleTreeZones() {
    setState(() {
      _showTreeZones = !_showTreeZones;
      if (_showTreeZones) {
        _treeZones = _elements
            .where((e) => e.type == 'tree')
            .map((e) => TreeProtectionZone(
                  center: e.latLng!,
                  tpzRadius: (e.metadata?['tpzRadius'] ?? 0.0).toDouble(),
                  srzRadius: (e.metadata?['srzRadius'] ?? 0.0).toDouble(),
                ))
            .toList();
      } else {
        _treeZones = [];
      }
    });
  }

  Color _getColorForRetentionValue(String? value) {
    switch (value?.toLowerCase()) {
      case 'high':
        return Colors.red;
      case 'moderate':
        return Colors.orange;
      case 'low':
        return Colors.green;
      default:
        return Colors.grey;
    }
  }

  // === Image Overlay Methods ===
  Future<void> _pickAndPlaceImage() async {
    final XFile? image = await _picker.pickImage(source: ImageSource.gallery);
    if (image != null) {
      final mapCenter = _mapController.camera.center;
      final metersPerPixel = _getMetersPerPixel();
      final viewSize = MediaQuery.of(context).size;
      setState(() {
        _imageOverlay = ImageOverlay(
          id: Uuid().v4(),
          imagePath: image.path,
          center: mapCenter,
          width: viewSize.width * metersPerPixel * 0.5,
          height: viewSize.height * metersPerPixel * 0.5,
        );
      });
    }
  }

  String? _getOverlayActionAt(Offset localPosition) {
    if (_imageOverlay == null) return null;

    final centerOnScreen = _project(_imageOverlay!.center);
    final rotation = _imageOverlay!.rotation * pi / 180;
    final cosR = cos(rotation);
    final sinR = sin(rotation);
    
    // Transform tap position to the un-rotated frame of the image
    final dx = localPosition.dx - centerOnScreen.dx;
    final dy = localPosition.dy - centerOnScreen.dy;
    final tapX = dx * cosR + dy * sinR;
    final tapY = -dx * sinR + dy * cosR;

    final halfWidth = (_imageOverlay!.width / _getMetersPerPixel()) / 2;
    final halfHeight = (_imageOverlay!.height / _getMetersPerPixel()) / 2;
    
    // Define handle size
    const handleSize = 20.0;

    // Check corners for scaling
    if ((tapX - halfWidth).abs() < handleSize && (tapY - halfHeight).abs() < handleSize) return 'scale_br';
    if ((tapX + halfWidth).abs() < handleSize && (tapY - halfHeight).abs() < handleSize) return 'scale_bl';
    if ((tapX - halfWidth).abs() < handleSize && (tapY + halfHeight).abs() < handleSize) return 'scale_tr';
    if ((tapX + halfWidth).abs() < handleSize && (tapY + halfHeight).abs() < handleSize) return 'scale_tl';

    // Check top edge for rotation
    if (tapX.abs() < halfWidth && (tapY + halfHeight).abs() < handleSize + 10) return 'rotate';
    
    // Check if inside the image for moving
    if (tapX.abs() < halfWidth && tapY.abs() < halfHeight) return 'move';

    return null;
  }
  
  void _updateOverlay(Offset delta) {
    if (_imageOverlay == null || _selectedOverlayAction == null) return;
    
    setState(() {
      switch (_selectedOverlayAction) {
        case 'move':
          final newCenterPoint = _project(_imageOverlay!.center) + delta;
          _imageOverlay!.center = _unproject(newCenterPoint);
          break;
        case 'rotate':
          final center = _project(_imageOverlay!.center);
          final originalVector = _previousPanPosition! - center;
          final newVector = (_previousPanPosition! + delta) - center;
          _imageOverlay!.rotation += newVector.direction - originalVector.direction;
          break;
        case 'scale_br':
        case 'scale_bl':
        case 'scale_tr':
        case 'scale_tl':
           final metersPerPixel = _getMetersPerPixel();
          _imageOverlay!.width += delta.dx * metersPerPixel;
          _imageOverlay!.height += delta.dy * metersPerPixel;
          break;
      }
    });
    _previousPanPosition = (_previousPanPosition ?? Offset.zero) + delta;
  }
  
  Offset? _previousPanPosition;


  // === UI Builder Methods ===
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[100],
      appBar: PreferredSize(
        preferredSize: Size.fromHeight(80),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 2, offset: Offset(0, 1))],
          ),
          child: Column(
            children: [
              // Top menu bar
              Container(
                height: 30,
                color: Colors.grey[200],
                child: Row(
                  children: [
                    _buildMenuButton('File'),
                    _buildMenuButton('Edit'),
                    _buildMenuButton('View'),
                    _buildMenuButton('Tools'),
                    _buildMenuButton('Window'),
                    Spacer(),
                    Text('ArborCAD - ${widget.site.name}', style: TextStyle(fontSize: 12)),
                    SizedBox(width: 16),
                  ],
                ),
              ),
              // Main toolbar
              Container(
                height: 50,
                padding: EdgeInsets.symmetric(horizontal: 8),
                child: Row(
                  children: [
                    _buildToolGroup([
                      _buildToolButton(Icons.mouse, 'select', 'Select'),
                      _buildToolButton(Icons.pan_tool, 'pan', 'Pan'),
                      _buildToolButton(Icons.zoom_in, 'zoom', 'Zoom'),
                    ]),
                    _buildSeparator(),
                    _buildToolGroup([
                      _buildToolButton(Icons.timeline, 'line', 'Line'),
                      _buildToolButton(Icons.crop_square, 'rectangle', 'Rectangle'),
                      _buildToolButton(Icons.circle_outlined, 'circle', 'Circle'),
                      _buildToolButton(Icons.polyline, 'polygon', 'Polygon'),
                    ]),
                    _buildSeparator(),
                    _buildToolGroup([
                      _buildToolButton(Icons.text_fields, 'text', 'Text'),
                      _buildToolButton(Icons.straighten, 'dimension', 'Dimension'),
                      _buildToolButton(Icons.arrow_forward, 'arrow', 'Arrow'),
                    ]),
                    _buildSeparator(),
                    _buildColorPicker(),
                    _buildLineWidthSelector(),
                    Spacer(),
                    _buildToolButton(Icons.save, 'save', 'Save'),
                    _buildToolButton(Icons.picture_as_pdf, 'export', 'Export PDF'),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
      body: Row(
        children: [
          // Left sidebar tool palette
          Container(
            width: 40,
            color: Colors.grey[200],
            child: Column(
              children: [
                _buildSidebarTool(Icons.home, 'house', 'House'),
                _buildSidebarTool(Icons.drive_eta, 'driveway', 'Driveway'),
                _buildSidebarTool(Icons.grass, 'garden', 'Garden'),
                _buildSidebarTool(Icons.fence, 'fence', 'Fence'),
                Divider(),
                _buildSidebarTool(Icons.layers, 'layers', 'Layers'),
                _buildSidebarTool(Icons.undo, 'undo', 'Undo'),
                _buildSidebarTool(Icons.redo, 'redo', 'Redo'),
              ],
            ),
          ),
          // Main drawing area
          Expanded(
            child: Container(
              color: Colors.white,
              child: _buildDrawingCanvas(),
            ),
          ),
        ],
      ),
    );
  }

  void _showMapSettings() {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return StatefulBuilder(builder: (context, setSheetState) {
          return Container(
            padding: EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text('Map Settings', style: Theme.of(context).textTheme.headlineMedium),
                ListTile(
                  title: Text('Map Opacity'),
                  subtitle: Slider(
                    min: 0.1,
                    max: 1.0,
                    value: _tileLayerOpacity,
                    onChanged: (value) {
                      setSheetState(() {
                        _tileLayerOpacity = value;
                      });
                      setState(() {}); // Update the map behind the sheet
                    },
                  ),
                  trailing: Text(_tileLayerOpacity.toStringAsFixed(2)),
                ),
              ],
            ),
          );
        });
      },
    );
  }

  Widget _buildActiveLayerIndicator() {
    final activeLayer = _layers.firstWhere((l) => l.id == _selectedLayerId);
    return Container(
      color: Colors.grey[200],
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text('Active Layer: '),
          SizedBox(width: 8),
          Container(
            width: 16,
            height: 16,
            color: activeLayer.color,
          ),
          SizedBox(width: 8),
          Text(
            activeLayer.name,
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          if (activeLayer.locked) ...[
            SizedBox(width: 8),
            Icon(Icons.lock, size: 16, color: Colors.red),
            Text(' (Locked)', style: TextStyle(color: Colors.red)),
          ]
        ],
      ),
    );
  }

  Widget _buildToolbar() {
    final isResponsive = MediaQuery.of(context).size.width < 600;
    final tools = [
      _toolbarButton(Icons.mouse, 'select', 'Select & Edit'),
      _toolbarButton(Icons.timeline, 'line', 'Line'),
      _toolbarButton(Icons.format_shapes, 'polygon', 'Polygon'),
      _toolbarButton(Icons.radio_button_unchecked, 'circle', 'Circle'),
      _toolbarButton(Icons.text_fields, 'text', 'Text'),
      _toolbarButton(Icons.straighten, 'dimension', 'Dimension'),
      _toolbarButton(Icons.north_east, 'arrow', 'Arrow'),
      _toolbarButton(Icons.check_box_outline_blank, 'rectangle', 'Rectangle'),
      _toolbarButton(Icons.park, 'show_tpz', 'Tree Zones'),
      _toolbarButton(Icons.add_photo_alternate, 'image', 'Add Image'),
      IconButton(
        icon: Icon(Icons.settings_input_component,
            color: _isSnappingEnabled ? Colors.blue : Colors.black),
        onPressed: () {
          setState(() {
            _isSnappingEnabled = !_isSnappingEnabled;
          });
        },
        tooltip: 'Toggle Snapping',
      ),
    ];

    if (isResponsive) {
      return Container(
        width: 56,
        color: Theme.of(context).primaryColorLight,
        child: Column(children: tools),
      );
    }

    return Container(
      width: 120,
      color: Theme.of(context).primaryColorLight,
      child: ListView(
        children: tools
            .map((b) => Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: b,
                ))
            .toList(),
      ),
    );
  }

  Widget _toolbarButton(IconData icon, String tool, String tooltip) {
    final isSelected = _currentTool == tool;
    return IconButton(
      icon: Icon(icon, color: isSelected ? Colors.blue : Colors.black),
      tooltip: tooltip,
      onPressed: () {
        if (tool == 'show_tpz') {
          _toggleTreeZones();
        } else if (tool == 'image') {
          _pickAndPlaceImage();
        } else {
          setState(() {
            _currentTool = tool;
            // ArborCAD-style UI components
  Widget _buildMenuButton(String title) {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: 8),
      child: TextButton(
        onPressed: () {},
        style: TextButton.styleFrom(
          padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          minimumSize: Size.zero,
        ),
        child: Text(title, style: TextStyle(fontSize: 12, color: Colors.black87)),
      ),
    );
  }

  Widget _buildToolButton(IconData icon, String tool, String tooltip) {
    final isSelected = _currentTool == tool;
    return Container(
      margin: EdgeInsets.all(2),
      child: Material(
        color: isSelected ? Colors.blue[100] : Colors.transparent,
        borderRadius: BorderRadius.circular(4),
        child: InkWell(
          borderRadius: BorderRadius.circular(4),
          onTap: () => _selectTool(tool),
          child: Container(
            width: 32,
            height: 32,
            child: Icon(
              icon,
              size: 18,
              color: isSelected ? Colors.blue[800] : Colors.black87,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildToolGroup(List<Widget> tools) {
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 4),
      child: Row(children: tools),
    );
  }

  Widget _buildSeparator() {
    return Container(
      width: 1,
      height: 30,
      color: Colors.grey[300],
      margin: EdgeInsets.symmetric(horizontal: 4),
    );
  }

  Widget _buildColorPicker() {
    return Container(
      margin: EdgeInsets.all(2),
      child: Material(
        borderRadius: BorderRadius.circular(4),
        child: InkWell(
          borderRadius: BorderRadius.circular(4),
          onTap: _showColorPicker,
          child: Container(
            width: 32,
            height: 32,
            decoration: BoxDecoration(
              color: _drawingColor,
              border: Border.all(color: Colors.grey[400]!),
              borderRadius: BorderRadius.circular(4),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLineWidthSelector() {
    return Container(
      margin: EdgeInsets.all(2),
      child: DropdownButton<double>(
        value: _strokeWidth,
        underline: Container(),
        items: [0.5, 1.0, 2.0, 3.0, 5.0].map((width) {
          return DropdownMenuItem(
            value: width,
            child: Text('${width}px', style: TextStyle(fontSize: 12)),
          );
        }).toList(),
        onChanged: (value) => setState(() => _strokeWidth = value!),
      ),
    );
  }

  Widget _buildSidebarTool(IconData icon, String tool, String tooltip) {
    final isSelected = _currentTool == tool;
    return Container(
      margin: EdgeInsets.all(2),
      child: Material(
        color: isSelected ? Colors.blue[100] : Colors.transparent,
        borderRadius: BorderRadius.circular(4),
        child: InkWell(
          borderRadius: BorderRadius.circular(4),
          onTap: () => _selectTool(tool),
          child: Container(
            width: 36,
            height: 36,
            child: Icon(
              icon,
              size: 20,
              color: isSelected ? Colors.blue[800] : Colors.black87,
            ),
          ),
        ),
      ),
    );
  }

  void _selectTool(String tool) {
    setState(() {
      _currentTool = tool;
      _resetDrawingState();
    });
    
    // Handle special tools
    switch (tool) {
      case 'save':
        _saveDrawing();
        break;
      case 'export':
        _exportPDF();
        break;
      case 'layers':
        _showLayerManager();
        break;
      case 'undo':
        _undo();
        break;
      case 'redo':
        _redo();
        break;
    }
  }

  void _showColorPicker() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Select Color'),
        content: SingleChildScrollView(
          child: ColorPicker(
            pickerColor: _drawingColor,
            onColorChanged: (color) => _drawingColor = color,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              setState(() {});
              Navigator.pop(context);
            },
            child: Text('OK'),
          ),
        ],
      ),
    );
  }

  void _exportPDF() {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('PDF export feature coming soon')),
    );
  }

  Widget _buildDrawingCanvas() {
    return Container(
      color: Colors.white,
      child: Stack(
        children: [
          FlutterMap(
            mapController: _mapController,
            options: MapOptions(
              initialCenter: LatLng(widget.site.latitude, widget.site.longitude),
              initialZoom: 18.0,
              backgroundColor: Colors.white,
              onTap: (tapPosition, point) {
                final screenPoint = Offset(
                  tapPosition.global.dx,
                  tapPosition.global.dy,
                );
                _handleTap(screenPoint);
              },
            ),
            children: [
              Opacity(
                opacity: _tileLayerOpacity,
                child: TileLayer(
                  urlTemplate: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                  userAgentPackageName: 'com.example.arborist_assistant',
                  tileProvider: NetworkTileProvider(),
                  tileBuilder: (context, widget, tile) {
                    return ColorFiltered(
                      colorFilter: ColorFilter.mode(
                        Colors.white.withOpacity(0.7),
                        BlendMode.lighten,
                      ),
                      child: widget,
                    );
                  },
                ),
              ),
              if (_imageOverlay != null)
                RotatedBox(
                  quarterTurns: 0, // Manage rotation via transform
                  child: OverlayImageLayer(
                    overlayImages: [
                      OverlayImage(
                        bounds: LatLngBounds(
                          LatLng(
                              _imageOverlay!.center.latitude -
                                  _imageOverlay!.height / 222000, // Approx conversion
                              _imageOverlay!.center.longitude -
                                  _imageOverlay!.width / 222000 / cos(_imageOverlay!.center.latitude * pi / 180)),
                          LatLng(
                              _imageOverlay!.center.latitude +
                                  _imageOverlay!.height / 222000,
                              _imageOverlay!.center.longitude +
                                  _imageOverlay!.width / 222000 / cos(_imageOverlay!.center.latitude * pi / 180))),
                        imageProvider: FileImage(File(_imageOverlay!.imagePath)),
                        opacity: _imageOverlay!.opacity,
                        // rotation: _imageOverlay!.rotation,
                      ),
                    ],
                  ),
                ),
              if (_treesLoaded)
                MarkerLayer(
                    markers: _elements
                        .where((e) => e.type == 'tree' && e.latLng != null)
                        .toList()
                        .asMap()
                        .entries
                        .map((entry) {
                          int index = entry.key;
                          DrawingElement element = entry.value;
                          return Marker(
                            point: element.latLng!,
                            width: 40,
                            height: 40,
                            child: Container(
                              decoration: BoxDecoration(
                                color: _getColorForRetentionValue(
                                    element.metadata?['retentionValue']),
                                shape: BoxShape.circle,
                                border:
                                    Border.all(color: Colors.white, width: 2),
                              ),
                              child: Center(
                                  child: Text((index + 1).toString(),
                                      style: TextStyle(
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold))),
                            ),
                            rotate: false, // This will prevent the marker from scaling
                          );
                        })
                        .toList()),
            ],
          ),
          if (_currentPolyline.isNotEmpty || _previewPoint != null)
            Positioned.fill(
              child: CustomPaint(
                painter: DrawingPreviewPainter(
                  polyline: _currentPolyline,
                  previewPoint: _previewPoint,
                  currentTool: _currentTool,
                  strokeColor: _drawingColor,
                  strokeWidth: _strokeWidth,
                ),
              ),
            ),
        ],
      ),
    );
  }
            _selectedElementId = null;
            _currentPolyline = [];
            _previewPoint = null;
          });
        }
      },
    );
  }
  
  Widget _buildMapArea() {
    return Stack(
      children: [
        FlutterMap(
          mapController: _mapController,
          options: MapOptions(
            initialCenter: LatLng(widget.site.latitude ?? 0.0, widget.site.longitude ?? 0.0),
            initialZoom: 18,
            onPositionChanged: (position, hasGesture) {
              if (hasGesture) {
                setState(() {
                  // Redraw canvas on map move
                });
              }
            },
            onTap: (_, latLng) {
               // This is handled by the GestureDetector now
            },
          ),
          children: [
            Opacity(
              opacity: _tileLayerOpacity,
              child: TileLayer(
                  urlTemplate: _tileLayers[_currentTileLayerIndex]['url']!,
                  subdomains: ['a', 'b','c'], // For OpenStreetMap and other {s} layers
                  userAgentPackageName: 'com.example.app',
              ),
            ),
            if (_imageOverlay != null)
              RotatedBox(
                quarterTurns: 0, // Manage rotation via transform
                child: OverlayImageLayer(
                  overlayImages: [
                    OverlayImage(
                      bounds: LatLngBounds(
                        LatLng(
                            _imageOverlay!.center.latitude -
                                _imageOverlay!.height / 222000, // Approx conversion
                            _imageOverlay!.center.longitude -
                                _imageOverlay!.width / 222000 / cos(_imageOverlay!.center.latitude * pi / 180)),
                        LatLng(
                            _imageOverlay!.center.latitude +
                                _imageOverlay!.height / 222000,
                            _imageOverlay!.center.longitude +
                                _imageOverlay!.width / 222000 / cos(_imageOverlay!.center.latitude * pi / 180))),
                      imageProvider: FileImage(File(_imageOverlay!.imagePath)),
                      opacity: _imageOverlay!.opacity,
                      // rotation: _imageOverlay!.rotation,
                    ),
                  ],
                ),
              ),
            if (_treesLoaded)
              MarkerLayer(
                  markers: _elements
                      .where((e) => e.type == 'tree' && e.latLng != null)
                      .toList()
                      .asMap()
                      .entries
                      .map((entry) {
                        int index = entry.key;
                        DrawingElement element = entry.value;
                        return Marker(
                          point: element.latLng!,
                          width: 40,
                          height: 40,
                          child: Container(
                            decoration: BoxDecoration(
                              color: _getColorForRetentionValue(
                                  element.metadata?['retentionValue']),
                              shape: BoxShape.circle,
                              border:
                                  Border.all(color: Colors.white, width: 2),
                            ),
                            child: Center(
                                child: Text((index + 1).toString(),
                                    style: TextStyle(
                                        color: Colors.white,
                                        fontWeight: FontWeight.bold))),
                          ),
                          rotate: false, // This will prevent the marker from scaling
                        );
                      })
                      .toList()),
          ],
        ),
        if (_drawMode)
          Positioned.fill(
            child: MouseRegion(
              onHover: (event) {
                if (_currentTool != 'select' && _currentPolyline.isNotEmpty) {
                  setState(() {
                    _previewPoint = event.localPosition;
                  });
                }
                _updateSnapPoint(event.localPosition);
              },
              child: GestureDetector(
                onTapUp: (details) {
                  final finalTapPosition = _snapPoint?.position ?? details.localPosition;
                  _handleTap(finalTapPosition);
                },
                onPanStart: (details) {
                  _previousPanPosition = details.localPosition;
                  if (_currentTool == 'select') {
                    final overlayAction =
                        _getOverlayActionAt(details.localPosition);
                    if (overlayAction != null) {
                      setState(() {
                        _selectedOverlayAction = overlayAction;
                      });
                      return;
                    }

                    _selectElementAt(details.localPosition);
                    if (_selectedElementId != null) {
                      final handles = _getElementHandles(_elements
                          .firstWhere((e) => e.id == _selectedElementId));
                      for (var i = 0; i < handles.length; i++) {
                        if ((handles[i] - details.localPosition).distance <
                            10) {
                          _resizeHandleIndex = i;
                          break;
                        }
                      }
                      setState(() {
                        _isMovingSelection = true;
                      });
                    }
                  } else {
                    // Start of a drag-to-draw gesture
                    setState(() {
                      _currentPolyline = [details.localPosition];
                    });
                  }
                },
                onPanUpdate: (details) {
                  if (_selectedOverlayAction != null) {
                    _updateOverlay(details.delta);
                    return;
                  }

                  if (_isMovingSelection && _selectedElementId != null) {
                    // Snapping logic for moving/resizing can be added here later
                    if (_resizeHandleIndex != null) {
                      _resizeSelectedElement(details.delta);
                    } else {
                      _moveSelectedElement(details.delta);
                    }
                  } else if (_currentPolyline.isNotEmpty) {
                    setState(() {
                      _previewPoint = details.localPosition;
                    });
                  }
                  _updateSnapPoint(details.localPosition);
                },
                onPanEnd: (details) {
                  setState(() {
                    if (_selectedOverlayAction != null) {
                      _selectedOverlayAction = null;
                    } else if (_isMovingSelection) {
                      _isMovingSelection = false;
                      _resizeHandleIndex = null;
                    } else if (_currentTool != 'select' &&
                        _currentPolyline.isNotEmpty &&
                        _previewPoint != null) {
                      // This was a drag-to-draw gesture
                      final finalPanPosition = _snapPoint?.position ?? _previewPoint!;
                      final points = [..._currentPolyline, finalPanPosition];
                      _finalizeDrawing(finalPanPosition, points);
                    }
                    _previousPanPosition = null;
                    _snapPoint = null;
                  });
                },
                child: CustomPaint(
                  painter: DrawingPainter(
                    elements: _elements,
                    currentPolyline: _currentPolyline,
                    previewPoint: _previewPoint,
                    currentTool: _currentTool,
                    layers: _layers,
                    treeZones: _treeZones,
                    selectedElementId: _selectedElementId,
                    imageOverlay: _imageOverlay,
                    selectedOverlayAction: _selectedOverlayAction,
                    mapController: _mapController,
                    snapPoint: _snapPoint,
                  ),
                  size: Size.infinite,
                ),
              ),
            ),
          ),
      ],
    );
  }

  Widget? _buildPolygonFab() {
    if (_currentTool == 'polygon' && _currentPolyline.length > 1) {
      return FloatingActionButton(
        onPressed: () => _finalizeDrawing(_currentPolyline.last, _currentPolyline),
        child: Icon(Icons.check),
        tooltip: 'Finish Polygon',
      );
    }
    return null;
  }

  Widget _buildPropertiesPanel() {
    final selectedElement = _selectedElementId != null
        ? _elements.firstWhere((e) => e.id == _selectedElementId)
        : null;
    final isResponsive = MediaQuery.of(context).size.width < 800;

    return Container(
      width: isResponsive ? 200 : 300,
      color: Colors.grey[200],
      padding: EdgeInsets.all(8.0),
      child: ListView(
        children: [
          if (selectedElement != null) ...[
            Text('Properties', style: Theme.of(context).textTheme.titleLarge),
            Divider(),
            Text('Type: ${selectedElement.type}'),
            SizedBox(height: 10),
            _buildColorEditor(selectedElement),
            if (selectedElement.type != 'text')
              _buildLineWidthEditor(selectedElement),
            if (selectedElement.type == 'text' && selectedElement.text != null)
              _buildTextEditor(selectedElement),
            if (selectedElement.type.contains('polygon') ||
                selectedElement.type == 'rectangle')
              _buildFillStyleEditor(selectedElement),
            Divider(),
            _buildMeasurementInfo(selectedElement),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: _deleteSelectedElement,
              child: Text('Delete Element'),
              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            )
          ] else if (_imageOverlay != null) ...[
            Text('Image Properties',
                style: Theme.of(context).textTheme.titleLarge),
            Divider(),
            _buildOpacityEditor(_imageOverlay!),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () => setState(() => _imageOverlay = null),
              child: Text('Remove Image'),
              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            ),
          ]
        ],
      ),
    );
  }

  Widget _buildOpacityEditor(ImageOverlay overlay) {
    return ListTile(
      title: Text('Opacity'),
      subtitle: Slider(
        min: 0.0,
        max: 1.0,
        value: overlay.opacity,
        onChanged: (value) {
          setState(() {
            overlay.opacity = value;
          });
        },
      ),
      trailing: Text(overlay.opacity.toStringAsFixed(2)),
    );
  }

  Widget _buildColorEditor(DrawingElement element) {
    return ListTile(
      title: Text('Color'),
      trailing: CircleAvatar(backgroundColor: element.color, radius: 15),
      onTap: () {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Pick a color'),
            content: SingleChildScrollView(
              child: ColorPicker(
                pickerColor: element.color,
                onColorChanged: (color) {
                  setState(() {
                    element.color = color;
                  });
                },
              ),
            ),
            actions: [
              TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text('Done'))
            ],
          ),
        );
      },
    );
  }

  Widget _buildLineWidthEditor(DrawingElement element) {
    return ListTile(
      title: Text('Line Width'),
      subtitle: Slider(
        min: 1,
        max: 20,
        value: element.lineWidth ?? 2.0,
        onChanged: (value) {
          setState(() {
            element.lineWidth = value;
          });
        },
      ),
      trailing: Text((element.lineWidth ?? 2.0).toStringAsFixed(1)),
    );
  }

  Widget _buildTextEditor(DrawingElement element) {
    final controller = TextEditingController(text: element.text);
    return ListTile(
      title: Text('Text Content'),
      subtitle: TextField(
        controller: controller,
        onSubmitted: (newText) {
          setState(() {
            element.text = newText;
          });
        },
      ),
    );
  }
   
  Widget _buildFillStyleEditor(DrawingElement element) {
    return ListTile(
      title: Text('Fill Style'),
      trailing: DropdownButton<String>(
        value: element.fillStyle ?? 'none',
        items: ['none', 'solid', 'hatch'].map((String value) {
          return DropdownMenuItem<String>(
            value: value,
            child: Text(value),
          );
        }).toList(),
        onChanged: (newValue) {
          setState(() {
            element.fillStyle = newValue;
          });
        },
      ),
    );
  }


  Widget _buildMeasurementInfo(DrawingElement element) {
    List<Widget> measurementWidgets = [];

    // Helper to calculate geodesic distance using geolocator
    double calculateDistance(LatLng p1, LatLng p2) {
      return Geolocator.distanceBetween(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
    }

    switch (element.type) {
      case 'line':
      case 'dimension':
      case 'arrow':
        if (element.latLng != null && element.endLatLng != null) {
          final length =
              calculateDistance(element.latLng!, element.endLatLng!);
          measurementWidgets.add(Text('Length: ${length.toStringAsFixed(2)} m'));
        }
        break;
      case 'circle':
        if (element.metadata?['radius_meters'] != null) {
          final radius = element.metadata!['radius_meters'];
          final area = pi * pow(radius, 2);
          final circumference = 2 * pi * radius;
          measurementWidgets
              .add(Text('Radius: ${radius.toStringAsFixed(2)} m'));
          measurementWidgets
              .add(Text('Area: ${area.toStringAsFixed(2)} mÂ²'));
          measurementWidgets.add(
              Text('Circumference: ${circumference.toStringAsFixed(2)} m'));
        }
        break;
      case 'polygon':
      case 'rectangle':
      case 'encroachment':
      case 'paving':
      case 'planting':
        if (element.latLngPoints != null && element.latLngPoints!.length > 2) {
          double perimeter = 0;
          for (int i = 0; i < element.latLngPoints!.length; i++) {
            perimeter += calculateDistance(element.latLngPoints![i], element.latLngPoints![(i + 1) % element.latLngPoints!.length]);
          }
          // Note: Area calculation for spherical polygons is complex. This is a simplified approximation.
          final area = _calculatePolygonArea(element.latLngPoints!);
          measurementWidgets.add(Text('Perimeter: ${perimeter.toStringAsFixed(2)} m'));
          measurementWidgets.add(Text('Area: ${area.toStringAsFixed(2)} mÂ²'));
        }
        break;
    }
    return Column(crossAxisAlignment: CrossAxisAlignment.start, children: measurementWidgets);
  }

  double _calculatePolygonArea(List<LatLng> points) {
    // Shoelace formula for area of a planar polygon.
    // This is an approximation and doesn't account for earth's curvature.
    if (points.length < 3) return 0.0;
    
    // For simplicity, we can't directly use LatLng in shoelace.
    // A better approach would be to project to a local cartesian plane, but that's complex.
    // For now, returning 0.0 as a placeholder for a proper geometric calculation.
    return 0.0;
  }
  
  // === Layer Management ===
  void _showLayerManager() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Layer Manager'),
        content: Container(
          width: double.maxFinite,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ...(_layers.map((layer) => ListTile(
                    leading: CircleAvatar(backgroundColor: layer.color),
                    title: Text(layer.name),
                    subtitle: Text(layer.locked ? 'Locked' : 'Unlocked'),
                    trailing: PopupMenuButton(
                      itemBuilder: (context) => [
                        PopupMenuItem(
                          child: Text('Edit'),
                          onTap: () => _editLayer(layer),
                        ),
                        PopupMenuItem(
                          child: Text(layer.locked ? 'Unlock' : 'Lock'),
                          onTap: () => _toggleLayerLock(layer),
                        ),
                        PopupMenuItem(
                          child: Text('Delete'),
                          onTap: () => _deleteLayer(layer),
                        ),
                      ],
                    ),
                    onTap: () => setState(() => _selectedLayerId = layer.id),
                    selected: _selectedLayerId == layer.id,
                  ))),
              Divider(),
              ListTile(
                leading: Icon(Icons.add),
                title: Text('Add Layer'),
                onTap: () => _addLayerWithDialog(),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Close'),
          ),
        ],
      ),
    );
  }

  void _addLayerWithDialog() async {
    final nameController = TextEditingController();
    Color selectedColor = Colors.blue;
    
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text('Create New Layer'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: nameController,
                decoration: InputDecoration(
                  labelText: 'Layer Name',
                  hintText: 'Enter layer name',
                ),
                autofocus: true,
              ),
              SizedBox(height: 16),
              Row(
                children: [
                  Text('Color: '),
                  GestureDetector(
                    onTap: () async {
                      final color = await showDialog<Color>(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: Text('Pick Color'),
                          content: SingleChildScrollView(
                            child: ColorPicker(
                              pickerColor: selectedColor,
                              onColorChanged: (color) => selectedColor = color,
                            ),
                          ),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: Text('Cancel'),
                            ),
                            TextButton(
                              onPressed: () => Navigator.pop(context, selectedColor),
                              child: Text('Select'),
                            ),
                          ],
                        ),
                      );
                      if (color != null) {
                        setState(() => selectedColor = color);
                      }
                    },
                    child: Container(
                      width: 40,
                      height: 40,
                      decoration: BoxDecoration(
                        color: selectedColor,
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                if (nameController.text.isNotEmpty) {
                  Navigator.pop(context, {
                    'name': nameController.text,
                    'color': selectedColor,
                  });
                }
              },
              child: Text('Create'),
            ),
          ],
        ),
      ),
    );

    if (result != null) {
      final newLayer = DrawingLayer(
        id: Uuid().v4(),
        name: result['name'],
        color: result['color'],
      );
      setState(() {
        _layers.add(newLayer);
        _selectedLayerId = newLayer.id;
      });
      Navigator.pop(context); // Close layer manager
    }
  }

  // === Drawing Properties and Auto-Draw ===
  
  void _showDrawingProperties() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Drawing Properties'),
        content: StatefulBuilder(
          builder: (context, setState) => Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  Text('Color: '),
                  GestureDetector(
                    onTap: () async {
                      final color = await showDialog<Color>(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: Text('Pick Color'),
                          content: SingleChildScrollView(
                            child: ColorPicker(
                              pickerColor: _drawingColor,
                              onColorChanged: (color) => _drawingColor = color,
                            ),
                          ),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: Text('Cancel'),
                            ),
                            TextButton(
                              onPressed: () => Navigator.pop(context, _drawingColor),
                              child: Text('Select'),
                            ),
                          ],
                        ),
                      );
                      if (color != null) {
                        setState(() => _drawingColor = color);
                     },
                    ),
                    child: Container(
                      width: 40,
                      height: 40,
                      decoration: BoxDecoration(
                        color: _drawingColor,
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                  ),
                ],
              ),
              SizedBox(height: 16),
              Row(
                children: [
                  Text('Stroke Width: '),
                  Expanded(
                    child: Slider(
                      value: _strokeWidth,
                      min: 0.5,
                      max: 10.0,
                      divisions: 19,
                      label: '${_strokeWidth.toStringAsFixed(1)}px',
                      onChanged: (value) => setState(() => _strokeWidth = value),
                    ),
                  ),
                ],
              ),
              SizedBox(height: 16),
              Row(
                children: [
                  Text('Fill Style: '),
                  DropdownButton<String>(
                    value: _fillStyle,
                    items: [
                      DropdownMenuItem(value: 'none', child: Text('None')),
                      DropdownMenuItem(value: 'solid', child: Text('Solid')),
                      DropdownMenuItem(value: 'hatch', child: Text('Hatch')),
                      DropdownMenuItem(value: 'dots', child: Text('Dots')),
                    ],
                    onChanged: (value) => setState(() => _fillStyle = value!),
                  ),
                ],
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Close'),
          ),
        ],
      ),
    );
  }

  void _toggleAutoDrawMode() {
    setState(() {
      _autoDrawMode = !_autoDrawMode;
      if (_autoDrawMode) {
        _showAutoDrawOptions();
      }
    });
  }

  void _showAutoDrawOptions() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Auto Draw Mode'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Select what to auto-draw:'),
            SizedBox(height: 16),
            ...[
              {'type': 'house', 'label': 'Houses', 'icon': Icons.home},
              {'type': 'driveway', 'label': 'Driveways', 'icon': Icons.drive_eta},
              {'type': 'boundary', 'label': 'Boundaries', 'icon': Icons.border_outer},
              {'type': 'garden', 'label': 'Garden Beds', 'icon': Icons.grass},
            ].map((item) => RadioListTile<String>(
              title: Row(
                children: [
                  Icon(item['icon'] as IconData),
                  SizedBox(width: 8),
                  Text(item['label'] as String),
                ],
              ),
              value: item['type'] as String,
              groupValue: _autoDrawType,
              onChanged: (value) => setState(() => _autoDrawType = value!),
            )),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Close'),
          ),
        ],
      ),
    );
  }

  String _getAutoDrawFillStyle() {
    switch (_autoDrawType) {
      case 'house': return 'solid';
      case 'driveway': return 'hatch';
      case 'boundary': return 'none';
      case 'garden': return 'dots';
      default: return 'none';
    }
  }

  Color _getAutoDrawColor() {
    switch (_autoDrawType) {
      case 'house': return Colors.brown;
      case 'driveway': return Colors.grey;
      case 'boundary': return Colors.black;
      case 'garden': return Colors.green;
      default: return _drawingColor;
    }
  }

  void _toggleLayerLock(DrawingLayer layer) {
    setState(() {
      layer.locked = !layer.locked;
    });
  }

  void _deleteLayer(DrawingLayer layer) {
    if (_layers.length <= 1) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Cannot delete the last layer')),
      );
      return;
    }
    
    setState(() {
      _layers.removeWhere((l) => l.id == layer.id);
      _elements.removeWhere((e) => e.layerId == layer.id);
      if (_selectedLayerId == layer.id) {
        _selectedLayerId = _layers.first.id;
      }
    });
  }

  void _editLayer(DrawingLayer layer) {
    final nameController = TextEditingController(text: layer.name);
    Color selectedColor = layer.color;
    
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text('Edit Layer'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: nameController,
                decoration: InputDecoration(
                  labelText: 'Layer Name',
                ),
              ),
              SizedBox(height: 16),
              Row(
                children: [
                  Text('Color: '),
                  GestureDetector(
                    onTap: () async {
                      final color = await showDialog<Color>(
                        context: context,
                        builder: (context) => AlertDialog(
                          title: Text('Pick Color'),
                          content: SingleChildScrollView(
                            child: ColorPicker(
                              pickerColor: selectedColor,
                              onColorChanged: (color) => selectedColor = color,
                            ),
                          ),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context),
                              child: Text('Cancel'),
                            ),
                            TextButton(
                              onPressed: () => Navigator.pop(context, selectedColor),
                              child: Text('Select'),
                            ),
                          ],
                        ),
                      );
                      if (color != null) {
                        setState(() => selectedColor = color);
                      }
                    },
                    child: Container(
                      width: 40,
                      height: 40,
                      decoration: BoxDecoration(
                        color: selectedColor,
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                setState(() {
                  layer.name = nameController.text;
                  layer.color = selectedColor;
                });
                Navigator.pop(context);
              },
              child: Text('Save'),
            ),
          ],
        ),
      ),
    );
  }

   // === Coordinate and Geometry Helpers ===
  
  Offset _project(LatLng latLng) {
    final point = _mapController.camera.project(latLng);
    return Offset(point.x, point.y);
  }

  LatLng _unproject(Offset offset) {
    final point = CustomPoint(offset.dx, offset.dy);
    return _mapController.camera.unproject(point);
  }
  
  double _getMetersPerPixel() {
    final bounds = _mapController.camera.visibleBounds;
    final viewSize = MediaQuery.of(context).size;
    final distanceInMeters = Geolocator.distanceBetween(
      bounds.southWest.latitude,
      bounds.southWest.longitude,
      bounds.northEast.latitude,
      bounds.northEast.longitude,
    );
    final distanceInPixels = sqrt(pow(viewSize.width, 2) + pow(viewSize.height, 2));
    return distanceInMeters / distanceInPixels;
  }
  
   // === Element Selection and Manipulation ===

  void _selectElementAt(Offset tapPosition) {
    String? newSelectedId;
    double minDistance = double.infinity;

    for (final element in _elements.reversed) {
       final layer = _layers.firstWhere((l) => l.id == element.layerId);
       if (!layer.visible || layer.locked) continue;

      final distance = _isPointOnElement(tapPosition, element);
      if (distance != null && distance < minDistance) {
        minDistance = distance;
        newSelectedId = element.id;
      }
    }

    setState(() {
      _selectedElementId = newSelectedId;
    });
  }

  double? _isPointOnElement(Offset point, DrawingElement element) {
    const threshold = 15.0; // pixels
    switch (element.type) {
      case 'line':
      case 'dimension':
      case 'arrow':
        if (element.latLng == null || element.endLatLng == null) return null;
        final p1 = _project(element.latLng!);
        final p2 = _project(element.endLatLng!);
        final distance = _distancePointToSegment(point, p1, p2);
        return distance < threshold ? distance : null;

      case 'polygon':
      case 'rectangle':
      case 'encroachment':
      case 'paving':
      case 'planting':
        if (element.latLngPoints == null) return null;
        final points = element.latLngPoints!.map((p) => _project(p)).toList();
        final path = ui.Path()..addPolygon(points, true);
        if (path.contains(point)) return 0; // Clicked inside
        for (int i = 0; i < points.length; i++) {
          final p1 = points[i];
          final p2 = points[(i + 1) % points.length];
          final distance = _distancePointToSegment(point, p1, p2);
          if (distance < threshold) return distance;
        }
        return null;

      case 'circle':
         if (element.latLng == null || element.radius == null) return null;
         final center = _project(element.latLng!);
         final distance = (point - center).distance;
         return (distance - element.radius!).abs() < threshold ? 0 : null;

      case 'text':
        if (element.latLng == null || element.text == null) return null;
        final textPainter = TextPainter(
          text: TextSpan(text: element.text, style: TextStyle(fontSize: 16)),
          textDirection: ui.TextDirection.ltr,
        )..layout();
        final textRect = _project(element.latLng!) & textPainter.size;
        return textRect.contains(point) ? 0 : null;
        
      default:
        return null;
    }
  }

  double _distancePointToSegment(Offset p, Offset a, Offset b) {
    final l2 = (a - b).distanceSquared;
    if (l2 == 0.0) return (p - a).distance;
    final t = (((p.dx - a.dx) * (b.dx - a.dx)) + ((p.dy - a.dy) * (b.dy - a.dy))) / l2;
    final clampedT = t.clamp(0.0, 1.0);
    final projection = a + (b - a) * clampedT;
    return (p - projection).distance;
  }

  void _moveSelectedElement(Offset delta) {
    if (_selectedElementId == null) return;
    
    setState(() {
      final element = _elements.firstWhere((e) => e.id == _selectedElementId);
      if (element.latLng != null) {
         final newPoint = _project(element.latLng!) + delta;
         element.latLng = _unproject(newPoint);
      }
      if (element.endLatLng != null) {
         final newPoint = _project(element.endLatLng!) + delta;
         element.endLatLng = _unproject(newPoint);
      }
      if (element.latLngPoints != null) {
        element.latLngPoints = element.latLngPoints!.map((p) {
          final newPoint = _project(p) + delta;
          return _unproject(newPoint);
        }).toList();
      }
    });
  }
  
  void _resizeSelectedElement(Offset delta) {
     if (_selectedElementId == null || _resizeHandleIndex == null) return;
     
     setState(() {
       final element = _elements.firstWhere((e) => e.id == _selectedElementId);
       final handles = _getElementHandles(element);
       final newHandlePos = handles[_resizeHandleIndex!] + delta;
       final newHandleLatLng = _unproject(newHandlePos);

       switch (element.type) {
          case 'line':
          case 'dimension':
          case 'arrow':
            if (_resizeHandleIndex == 0) element.latLng = newHandleLatLng;
            if (_resizeHandleIndex == 1) element.endLatLng = newHandleLatLng;
            break;
          case 'circle':
             if (_resizeHandleIndex == 0) { // Moving center
                element.latLng = newHandleLatLng;
             } else { // Adjusting radius
                final centerOnScreen = _project(element.latLng!);
                element.radius = (newHandlePos - centerOnScreen).distance;
                final radiusInMeters = Geolocator.distanceBetween(element.latLng!.latitude, element.latLng!.longitude, newHandleLatLng.latitude, newHandleLatLng.longitude);
                element.metadata = {'radius_meters': radiusInMeters};
             }
            break;
          case 'polygon':
          case 'rectangle':
             if (element.latLngPoints != null && _resizeHandleIndex! < element.latLngPoints!.length) {
                element.latLngPoints![_resizeHandleIndex!] = newHandleLatLng;
             }
            break;
       }
     });
  }
  
  List<Offset> _getElementHandles(DrawingElement element) {
     List<Offset> handles = [];
     switch (element.type) {
       case 'line':
       case 'dimension':
       case 'arrow':
         if (element.latLng != null && element.endLatLng != null) {
           handles.add(_project(element.latLng!));
           handles.add(_project(element.endLatLng!));
         }
         break;
       case 'circle':
         if (element.latLng != null && element.radius != null) {
           final center = _project(element.latLng!);
           handles.add(center); // Center handle
           handles.add(Offset(center.dx + element.radius!, center.dy)); // Radius handle
         }
         break;
       case 'polygon':
       case 'rectangle':
       case 'encroachment':
       case 'paving':
       case 'planting':
         if (element.latLngPoints != null) {
           handles = element.latLngPoints!.map((p) => _project(p)).toList();
         }
         break;
     }
     return handles;
   }

  void _updateSnapPoint(Offset cursorPosition) {
    if (!_isSnappingEnabled) {
      if (_snapPoint != null) {
        setState(() {
          _snapPoint = null;
        });
      }
      return;
    }

    SnapPoint? closestPoint;
    double minDistance = 20.0; // Snap radius in pixels

    for (final element in _elements) {
      final layer = _layers.firstWhere((l) => l.id == element.layerId);
      if (!layer.visible) continue;

      // Vertex Snapping
      final handles = _getElementHandles(element);
      for (final handle in handles) {
        final distance = (cursorPosition - handle).distance;
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = SnapPoint(handle, SnapType.vertex);
        }
      }

      // Midpoint Snapping
      List<Offset> segmentPoints = [];
      if (element.type == 'line' || element.type == 'dimension' || element.type == 'arrow') {
        if (element.latLng != null && element.endLatLng != null) {
          segmentPoints.addAll([_project(element.latLng!), _project(element.endLatLng!)]);
        }
      } else if (element.latLngPoints != null) {
        segmentPoints.addAll(element.latLngPoints!.map((p) => _project(p)).toList());
      }

      for (int i = 0; i < segmentPoints.length -1; i++) {
        final p1 = segmentPoints[i];
        final p2 = segmentPoints[i + 1];
        final midpoint = Offset((p1.dx + p2.dx) / 2, (p1.dy + p2.dy) / 2);
        final distance = (cursorPosition - midpoint).distance;
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = SnapPoint(midpoint, SnapType.midpoint);
        }
      }
      // for polygons, check midpoint of closing segment
      if(element.latLngPoints != null && element.latLngPoints!.length > 2 && element.type != 'line'){
        final p1 = segmentPoints.last;
        final p2 = segmentPoints.first;
        final midpoint = Offset((p1.dx + p2.dx) / 2, (p1.dy + p2.dy) / 2);
        final distance = (cursorPosition - midpoint).distance;
        if (distance < minDistance) {
          minDistance = distance;
          closestPoint = SnapPoint(midpoint, SnapType.midpoint);
        }
      }
    }

    if (_snapPoint != closestPoint) {
      setState(() {
        _snapPoint = closestPoint;
      });
    }
  }
}

enum SnapType { vertex, midpoint }

class SnapPoint {
  final Offset position;
  final SnapType type;

  SnapPoint(this.position, this.type);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SnapPoint &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          type == other.type;

  @override
  int get hashCode => position.hashCode ^ type.hashCode;
}


// === Custom Painter ===
class DrawingPainter extends CustomPainter {
  final List<DrawingElement> elements;
  final List<Offset> currentPolyline;
  final Offset? previewPoint;
  final String currentTool;
  final List<DrawingLayer> layers;
  final List<TreeProtectionZone> treeZones;
  final String? selectedElementId;
  final ImageOverlay? imageOverlay;
  final String? selectedOverlayAction;
  final MapController mapController;
  final SnapPoint? snapPoint;

  DrawingPainter({
    required this.elements,
    required this.currentPolyline,
    this.previewPoint,
    required this.currentTool,
    required this.layers,
    required this.treeZones,
    this.selectedElementId,
    this.imageOverlay,
    this.selectedOverlayAction,
    required this.mapController,
    this.snapPoint,
  });

  Offset _project(LatLng latLng) {
    return mapController.camera.project(latLng).toOffset();
  }

  @override
  void paint(ui.Canvas canvas, ui.Size size) {
    _drawTreeZones(canvas);

    for (final element in elements) {
      final layer = layers.firstWhere((l) => l.id == element.layerId,
          orElse: () =>
              DrawingLayer(id: 'default', name: 'Default', color: Colors.black));
      if (!layer.visible) continue;

      final paint = Paint()
        ..color = element.color.withOpacity(layer.opacity)
        ..strokeWidth = element.lineWidth ?? 2.0
        ..style = PaintingStyle.stroke;

      switch (element.type) {
        case 'line':
        case 'dimension':
        case 'arrow':
          _drawLine(canvas, element, paint);
          break;
        case 'circle':
          _drawCircle(canvas, element, paint);
          break;
        case 'polygon':
        case 'rectangle':
        case 'encroachment':
        case 'paving':
        case 'planting':
          _drawPolygon(canvas, element, paint);
          break;
        case 'text':
          _drawText(canvas, element);
          break;
      }
    }

    if (currentPolyline.isNotEmpty && previewPoint != null) {
       final paint = Paint()
        ..color = Colors.black.withOpacity(0.7)
        ..strokeWidth = 2.0
        ..style = PaintingStyle.stroke;
      
      final points = [...currentPolyline, previewPoint!];
      final path = ui.Path();
      path.moveTo(points.first.dx, points.first.dy);
      for (var i = 1; i < points.length; i++) {
        path.lineTo(points[i].dx, points[i].dy);
      }

      if (currentTool == 'rectangle') {
        canvas.drawRect(Rect.fromPoints(points.first, points.last), paint);
      } else if (currentTool == 'circle') {
        canvas.drawCircle(points.first, (points.last - points.first).distance, paint);
      } else {
         canvas.drawPath(path, paint);
      }
    }

    if (selectedElementId != null) {
      final element = elements.firstWhere((e) => e.id == selectedElementId);
      if (element.type != 'tree') {
        _highlightElement(canvas, element);
      }
    }

    if (imageOverlay != null) {
      _drawImageOverlayHandles(canvas);
    }

    if (snapPoint != null) {
      final paint = Paint()
        ..color = Colors.cyan
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2.0;
      if (snapPoint!.type == SnapType.vertex) {
        canvas.drawCircle(snapPoint!.position, 10.0, paint);
      } else { // Midpoint
        final path = ui.Path();
        path.moveTo(snapPoint!.position.dx, snapPoint!.position.dy - 10);
        path.lineTo(snapPoint!.position.dx + 10, snapPoint!.position.dy + 5);
        path.lineTo(snapPoint!.position.dx - 10, snapPoint!.position.dy + 5);
        path.close();
        canvas.drawPath(path, paint);
      }
    }
  }

  void _highlightElement(ui.Canvas canvas, DrawingElement element) {
    final paint = Paint()
      ..color = Colors.cyan.withOpacity(0.8)
      ..strokeWidth = element.lineWidth ?? 2.0 + 2.0
      ..style = PaintingStyle.stroke;

    switch (element.type) {
      case 'line':
      case 'dimension':
      case 'arrow':
        if (element.latLng != null && element.endLatLng != null) {
          canvas.drawLine(_project(element.latLng!), _project(element.endLatLng!), paint);
        }
        break;
      case 'circle':
        if (element.latLng != null && element.radius != null) {
          canvas.drawCircle(_project(element.latLng!), element.radius!, paint);
        }
        break;
      case 'polygon':
      case 'rectangle':
      case 'encroachment':
      case 'paving':
      case 'planting':
        if (element.latLngPoints != null) {
          final points = element.latLngPoints!.map((p) => _project(p)).toList();
          final path = ui.Path()..addPolygon(points, true);
          canvas.drawPath(path, paint);
        }
        break;
    }

    final handlePaint = Paint()
       ..color = Colors.cyan
       ..style = PaintingStyle.fill;
    final handles = _getElementHandles(element);
    for (final handle in handles) {
       canvas.drawCircle(handle, 8.0, handlePaint);
    }
  }

  void _drawImageOverlayHandles(ui.Canvas canvas) {
      final handlePaint = Paint()
      ..color = Colors.orangeAccent
      ..style = PaintingStyle.fill;

      final centerOnScreen = _project(imageOverlay!.center);
      final metersPerPixel = _getMetersPerPixelForPainter();
      final widthOnScreen = imageOverlay!.width / metersPerPixel;
      final heightOnScreen = imageOverlay!.height / metersPerPixel;
      
      final halfWidth = widthOnScreen / 2;
      final halfHeight = heightOnScreen / 2;
      
      final rotation = imageOverlay!.rotation * pi / 180;
      
      // Save canvas state
      canvas.save();
      
      // Translate and rotate canvas
      canvas.translate(centerOnScreen.dx, centerOnScreen.dy);
      canvas.rotate(rotation);
      
      // Draw handles in the rotated frame
      canvas.drawCircle(Offset(halfWidth, halfHeight), 10.0, handlePaint); // BR
      canvas.drawCircle(Offset(-halfWidth, halfHeight), 10.0, handlePaint); // BL
      canvas.drawCircle(Offset(halfWidth, -halfHeight), 10.0, handlePaint); // TR
      canvas.drawCircle(Offset(-halfWidth, -halfHeight), 10.0, handlePaint); // TL
      
      // Draw rotation handle
       final rotationHandlePaint = Paint()
      ..color = Colors.deepPurpleAccent
      ..style = PaintingStyle.fill;
      canvas.drawCircle(Offset(0, -halfHeight - 20), 12.0, rotationHandlePaint); 

      // Restore canvas to original state
      canvas.restore();
  }

  void _drawLine(ui.Canvas canvas, DrawingElement element, Paint paint) {
    if (element.latLng == null || element.endLatLng == null) return;
    canvas.drawLine(_project(element.latLng!), _project(element.endLatLng!), paint);
  }

  void _drawPolygon(ui.Canvas canvas, DrawingElement element, Paint paint) {
    if (element.latLngPoints == null || element.latLngPoints!.length < 2) return;
    final points = element.latLngPoints!.map((p) => _project(p)).toList();
    
    final path = ui.Path();
    path.moveTo(points.first.dx, points.first.dy);
    for (int i = 1; i < points.length; i++) {
       path.lineTo(points[i].dx, points[i].dy);
    }

    if (element.type != 'line') { // line here would be an open polyline
       path.close();
    }
   
    if (element.fillStyle == 'solid') {
      paint.style = PaintingStyle.fill;
      if (element.type == 'encroachment') {
         paint.color = Colors.yellow.withOpacity(0.5);
      }
    }

    canvas.drawPath(path, paint);

    if (element.fillStyle == 'hatch') {
      final layer = layers.firstWhere((l) => l.id == element.layerId);
      _drawHatchedFill(canvas, path, layer);
    }
  }

  void _drawCircle(ui.Canvas canvas, DrawingElement element, Paint paint) {
    if (element.latLng == null || element.radius == null) return;
    canvas.drawCircle(_project(element.latLng!), element.radius!, paint);
  }

  void _drawText(ui.Canvas canvas, DrawingElement element) {
    if (element.text == null || element.latLng == null) return;
    final textPainter = TextPainter(
      text: TextSpan(
        text: element.text,
        style: TextStyle(color: element.color, fontSize: 16),
      ),
      textDirection: ui.TextDirection.ltr,
    )..layout();
    textPainter.paint(canvas, _project(element.latLng!));
  }

  void _drawTreeZones(ui.Canvas canvas) {
    for (final zone in treeZones) {
       final srzRadiusInPixels = zone.srzRadius / _getMetersPerPixelForPainter();
       final tpzRadiusInPixels = zone.tpzRadius / _getMetersPerPixelForPainter();
      _drawDashedCircle(canvas, _project(zone.center), srzRadiusInPixels, Colors.red);
      _drawDashedCircle(canvas, _project(zone.center), tpzRadiusInPixels, Colors.blue);
    }
  }

  void _drawDashedCircle(
      ui.Canvas canvas, Offset center, double radius, Color color) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    const double dashWidth = 10.0;
    const double dashSpace = 5.0;
    final double circumference = 2 * pi * radius;
    
    for (double i = 0; i < circumference; i += dashWidth + dashSpace) {
      canvas.drawArc(
        Rect.fromCircle(center: center, radius: radius),
        i / radius, // start angle
        dashWidth / radius, // sweep angle
        false,
        paint,
      );
    }
  }

  void _drawHatchedFill(ui.Canvas canvas, ui.Path path, DrawingLayer layer) {
    final paint = Paint()
      ..color = layer.color.withOpacity(layer.opacity * 0.5)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    canvas.save();
    canvas.clipPath(path);
    final bounds = path.getBounds();
    for (double i = bounds.left - bounds.height; i < bounds.right; i += 10) {
      canvas.drawLine(Offset(i, bounds.top), Offset(i + bounds.height, bounds.bottom), paint);
    }
    canvas.restore();
  }
  
  double _getMetersPerPixelForPainter() {
    final bounds = mapController.camera.visibleBounds;
    final screenWidth = mapController.camera.nonRotatedSize.x;
    final horizontalDistance = Geolocator.distanceBetween(
      bounds.southWest.latitude,
      bounds.southWest.longitude,
      bounds.southEast.latitude,
      bounds.southEast.longitude,
    );
    return horizontalDistance / screenWidth;
  }

  List<Offset> _getElementHandles(DrawingElement element) {
     List<Offset> handles = [];
     switch (element.type) {
       case 'line':
       case 'dimension':
       case 'arrow':
         if (element.latLng != null && element.endLatLng != null) {
           handles.add(_project(element.latLng!));
           handles.add(_project(element.endLatLng!));
         }
         break;
       case 'circle':
         if (element.latLng != null && element.radius != null) {
           final center = _project(element.latLng!);
           handles.add(center); // Center handle
           handles.add(Offset(center.dx + element.radius!, center.dy)); // Radius handle
         }
         break;
       case 'polygon':
       case 'rectangle':
       case 'encroachment':
       case 'paving':
       case 'planting':
         if (element.latLngPoints != null) {
           handles = element.latLngPoints!.map((p) => _project(p)).toList();
         }
         break;
     }
     return handles;
   }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
